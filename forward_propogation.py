#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Aug 21 00:53:02 2019

@author: musahni
"""

import numpy as np



"""
SIMPLE NEURAL NETWORK
"""


# Weighted prediction
def neural_network(inp, weight):
    prediction = inp * weight
    return prediction


weight = 0.1

"""
We want to predict a basketball teams chances of winning a match
based on a single variable: average number of player toes.
"""
toes = [8.5, 9.5, 10, 9]
pred = neural_network(toes[2], weight)
print(pred)

# Making a prediction with multiple inputs

"""
We want to use the same principle of adjusting a variable
with a weight but now to predict the outcome of a basketball
match based on three input variables: avg player height,
team wins ratio, and number of fans.
"""


# taking a weighted sum
def w_sum(a, b):
    assert(len(a) == len(b))
    output = 0
    for i in range(len(a)):
        output += (a[i] * b[i])
    return output


weights = [0.1, 0.2, 0]


def neural_network(inp, weights):
    prediction = w_sum(inp, weights)
    return prediction


toes = [8.5, 9.5, 10, 9]
win_ratio = [0.65, 0.8, 0.8, 0.9]
n_fans = [1.2, 1.3, 0.5, 1.0]

inp = [toes[3], win_ratio[3], n_fans[3]]
prediction = neural_network(inp, weights)
print(prediction)

"""
This can all be done much more efficiently and neatly using numpy.
"""


def neural_network(inp, weights):
    prediction = inp.dot(weights)
    return prediction


weights = np.array([0.1, 0.2, 0])

toes = np.array([8.5, 9.5, 10, 9])
win_ratio = np.array([0.65, 0.8, 0.8, 0.9])
n_fans = np.array([1.2, 1.3, 0.5, 1.0])

inp = np.array([toes[3], win_ratio[3], n_fans[3]])

prediction = neural_network(inp, weights)
print(prediction)


"""
Instead of predicting just one output (prob of winning the match),
now we will try and predict multiple outputs (but using only one input):
whether the team is happy or sad, number of injured players and game win prob.
"""


def ele_mul(number, vector):
    n = len(vector)
    output = [0]*n
    assert(len(output) == n)
    for i in range(n):
        output[i] = number * vector[i]
    return output


weights = [0.3, 0.2, 0.9]


def neural_network(inp, weights):
    prediction = ele_mul(inp, weights)
    return prediction


win_ratio = np.array([0.65, 0.8, 0.8, 0.9])

inp = np.array(win_ratio[1])
prediction = neural_network(inp, weights)
print(prediction)

"""
Predicting multiple outputs using multiple inputs.
"""

weights = np.array([
                   [0.1, 0.1, -0.3],  # hurt
                   [0.1, 0.2, 0.0],  # win
                   [0.0, 1.3, 0.1]  # sad
                   ])


def w_sum(a, b):
    assert(len(a) == len(b))
    output = 0
    for i in range(len(a)):
        output += (a[i] * b[i])
    return output


def vect_mat_mul(vect, matrix):
    assert(len(vect) == len(matrix))
    output = [0, 0, 0]
    for i in range(len(vect)):
        output[i] = w_sum(vect, matrix[i])
    return output


def neural_network(inp, weights):
    prediction = vect_mat_mul(inp, weights)
    return prediction


toes = np.array([8.5, 9.5, 9.9, 9.0])
win_ratio = np.array([0.65, 0.8, 0.8, 0.9])
n_fans = np.array([1.2, 1.3, 0.5, 1.0])


inp = np.array([toes[0], win_ratio[0], n_fans[0]])
prediction = neural_network(inp, weights)
print(prediction)

"""
Predicting further using prediction:
here we take the predictions we generated by first multiplying
the weights with the values and then further multiply
them with more weights.
"""

hidden_layer_weights = np.array([[0.1, 0.2, -0.1],  # hid[0]
                                 [-0.1, 0.1, 0.9],  # hid[1]
                                 [0.1, 0.4, 0.1]])  # hid[2]

final_weights = np.array([[0.3, 1.1, -0.3],  # hurt?
                          [0.1, 0.2, 0.0],  # win?
                          [0.0, 1.3, 0.1]])  # sad?

weights = [hidden_layer_weights, final_weights]


def neural_network(inp, weights):
    hidden = vect_mat_mul(inp, weights[0])
    prediction = vect_mat_mul(hidden, weights[1])
    return prediction


inp = np.array([toes[0], win_ratio[0], n_fans[0]])
print(neural_network(inp, weights))

# Numpy version


def neural_network(inp, weights):
    hidden = inp.dot(weights[0].T)
    prediction = hidden.dot(weights[1].T)
    return prediction

print(neural_network(inp, weights))
